"use strict";class t{static t;static GetFSMRouter(){return void 0===t.t&&(t.t=new t),t.t}i=new RegExp(/\/(:\w+)(?:\[(?:09|AZ|AZ09)])?\/(?:.+\/)?(\1)(?:\[(?:09|AZ|AZ09)])?(?:\/|$)/g);h=new RegExp(/(?<=^|\/):(\w+)(?:\[(09|AZ|AZ09)])?(?=\/|$)/g);o=[];u=void 0;l=void 0;v=void 0;A=!1;p=[];S=!1;Z;_={};F={};constructor(){window.addEventListener("hashchange",this.CheckHash.bind(this))}static O(t,i){const s=t=>{let i=[t];return t.includes(":AZ09")&&i.push(...s(t.replace(/:AZ09/,":AZ")),...s(t.replace(/:AZ09/,":09"))),i},e=new Set(s(t));return[...s(i)].some((t=>e.has(t)))}StateAdd(t){let i=!1;return void 0===this._[t]&&(this._[t]={OnEnter:[],OnLeave:[]},this.F[t]={},void 0===this.Z&&(this.Z=t),i=!0),i}StateDel(t){let i=!1;if(void 0!==this._[t]){delete this._[t],void 0!==this.F[t]&&delete this.F[t];for(const i in this.F)void 0!==this.F[i][t]&&delete this.F[i][t];i=!0}return i}StateOnEnterAdd(t,i){let s=!1;return void 0!==this._[t]&&(this._[t].OnEnter.includes(i)||(this._[t].OnEnter.push(i),s=!0)),s}StateOnEnterDel(t,i){let s=!1;if(void 0!==this._[t]){const e=this._[t].OnEnter.indexOf(i);-1!==e&&(this._[t].OnEnter.splice(e,1),s=!0)}return s}StateOnLeaveAdd(t,i){let s=!1;return void 0!==this._[t]&&(this._[t].OnLeave.includes(i)||(this._[t].OnLeave.push(i),s=!0)),s}StateOnLeaveDel(t,i){let s=!1;if(void 0!==this._[t]){const e=this._[t].OnLeave.indexOf(i);-1!==e&&(this._[t].OnLeave.splice(e,1),s=!0)}return s}TransitionAdd(t,i){let s=!1;return void 0!==this._[t]&&void 0!==this._[i]&&void 0===this.F[t][i]&&(this.F[t][i]={OnBefore:[],OnAfter:[]},s=!0),s}TransitionDel(t,i){let s=!1;return void 0!==this._[t]&&void 0!==this._[i]&&void 0!==this.F[t][i]&&(delete this.F[t][i],s=!0),s}TransitionOnBeforeAdd(t,i,s){let e=!1;return void 0!==this._[t]&&void 0!==this._[i]&&void 0!==this.F[t][i]&&(this.F[t][i].OnBefore.push(s),e=!0),e}TransitionOnBeforeDel(t,i,s){let e=!1;if(void 0!==this._[t]&&void 0!==this._[i]&&void 0!==this.F[t][i]){const h=this.F[t][i].OnBefore.indexOf(s);-1!==h&&(this.F[t][i].OnBefore.splice(h,1),e=!0)}return e}TransitionOnAfterAdd(t,i,s){let e=!1;return void 0!==this._[t]&&void 0!==this._[i]&&void 0!==this.F[t][i]&&(this.F[t][i].OnAfter.push(s),e=!0),e}TransitionOnAfterDel(t,i,s){let e=!1;if(void 0!==this._[t]&&void 0!==this._[i]&&void 0!==this.F[t][i]){const h=this.F[t][i].OnAfter.indexOf(s);-1!==h&&(this.F[t][i].OnAfter.splice(h,1),e=!0)}return e}StateGet(){return this.Z}async StateSet(t){let i=!1;if(!this.S){if(this.S=!0,void 0!==this.Z&&void 0!==this._[t]&&void 0!==this.F[this.Z]&&void 0!==this.F[this.Z][t]){let s;i=!0,s=this.F[this.Z][t].OnBefore.length;for(let e=0;i&&e<s;e++)if("function"==typeof this.F[this.Z][t].OnBefore[e]){let s=null;s="AsyncFunction"===this.F[this.Z][t].OnBefore[e].constructor.name?await this.F[this.Z][t].OnBefore[e]():this.F[this.Z][t].OnBefore[e](),i=!1!==s}if(i){s=this._[this.Z].OnLeave.length;for(let i=0;i<s;i++)"function"==typeof this._[this.Z].OnLeave[i]&&("AsyncFunction"===this._[this.Z].OnLeave[i].constructor.name?await this._[this.Z].OnLeave[i](this.Z,t):this._[this.Z].OnLeave[i](this.Z,t));let i=this.Z;this.Z=t,s=this.F[i][this.Z].OnAfter.length;for(let t=0;t<s;t++)"function"==typeof this.F[i][this.Z].OnAfter[t]&&("AsyncFunction"===this.F[i][this.Z].OnAfter[t].constructor.name?await this.F[i][this.Z].OnAfter[t]():this.F[i][this.Z].OnAfter[t]());s=this._[this.Z].OnEnter.length;for(let t=0;t<s;t++)"function"==typeof this._[this.Z].OnEnter[t]&&("AsyncFunction"===this._[this.Z].OnEnter[t].constructor.name?await this._[this.Z].OnEnter[t](this.Z,i):this._[this.Z].OnEnter[t](this.Z,i))}}this.S=!1}return i}CheckTransition(t){let i=!1;return this.S||void 0!==this.Z&&void 0!==this._[t]&&void 0!==this.F[this.Z]&&void 0!==this.F[this.Z][t]&&(i=!0),i}RouteSpecialAdd(t,i){let s=!1;switch(t){case 403:this.u=i,s=!0;break;case 404:this.l=i,s=!0;break;case 500:this.v=i,s=!0;break;default:throw new RangeError}return s}RouteAdd(i,s,e,h,n){let o=!1;if(void 0===this._[i])throw new SyntaxError("Non-existent state");if(s.match(this.i))throw new SyntaxError("Duplicate path id");{let r=0;const a=s.split("/"),d=a.length;for(let t=0;t<d;t++)a[t].startsWith(":")||(r+=2**(d-t-1));let u=new RegExp("^"+s.replace(this.h,(function(t,i,s){let e="(?<"+i+">[";switch(s){case"09":e+="\\d";break;case"AZ":e+="a-zA-Z";break;default:e+="a-zA-Z\\d"}return e+="]+)",e})).replace(/\//g,"\\/")+"$");const c=s.replace(this.h,((t,i,s)=>`:${s??"AZ09"}`));this.o.find((i=>t.O(c,i.path)))||(this.o.push({path:c,validState:i,match:u,weight:r,routeFunction:e,available:h,routeFunction403:n}),this.o.sort(((t,i)=>t.weight>i.weight?-1:i.weight>t.weight?1:0)),o=!0)}return o}RouteDel(i){let s=!1;if(i.match(this.i))throw new SyntaxError("Duplicate path id");{const e=i.replace(this.h,((t,i,s)=>`:${s??"AZ09"}`)),h=this.o.findIndex((i=>t.O(e,i.path)));-1<h&&(this.o.splice(h,1),s=!0)}return s}Trigger(t){"#"+t!=window.location.hash&&(window.location.hash="#"+t)}async Route(t){let i;this.A=!0;let s="",e=null;for(const h of this.o)if(e=h.match.exec(t)){s=h.path;let n=!1;h.available&&"function"==typeof h.available&&(n="AsyncFunction"===h.available.constructor.name?await h.available(s,t,e.groups??{}):h.available(s,t,e.groups??{})),n&&(void 0===h.validState||this.Z===h.validState||this.CheckTransition(h.validState))?h.validState&&this.Z!==h.validState?(i=h.routeFunction,await this.StateSet(h.validState)||(i=this.v)):i=this.v:h.routeFunction403?i=h.routeFunction403:this.u&&(i=this.u);break}i||this.l&&(i=this.l),"function"!=typeof i&&this.v&&(i=this.v),i&&"function"==typeof i&&("AsyncFunction"===i.constructor.name?await i(s,t,e?.groups??{}):i(s,t,e?.groups??{})),this.p.length?await this.Route(this.p.shift()):this.A=!1}async CheckHash(){const t=window.location.hash.startsWith("#")?window.location.hash.substring(1):"";""!=t&&(this.A?this.p.push(t):await this.Route(t))}}export default t.GetFSMRouter;
"use strict";class t{static t;static i(){return void 0===t.t&&(t.t=new t),t.t}h=new RegExp(/\/(:\w+)(?:\[(?:09|AZ|AZ09)])?\/(?:.+\/)?(\1)(?:\[(?:09|AZ|AZ09)])?(?:\/|$)/g);o=new RegExp(/(?<=^|\/):(\w+)(?:\[(09|AZ|AZ09)])?(?=\/|$)/g);u=[];l=void 0;v=void 0;A=void 0;p=!1;S=[];Z=!1;_;F={};O={};constructor(){window.addEventListener("hashchange",this.CheckHash.bind(this))}static D(t,i){const s=t=>{let i=[t];return t.includes(":AZ09")&&i.push(...s(t.replace(/:AZ09/,":AZ")),...s(t.replace(/:AZ09/,":09"))),i},e=new Set(s(t));return[...s(i)].some((t=>e.has(t)))}StateAdd(t){let i=!1;return void 0===this.F[t]&&(this.F[t]={OnEnter:[],OnLeave:[]},this.O[t]={},void 0===this._&&(this._=t),i=!0),i}StateDel(t){let i=!1;if(void 0!==this.F[t]){delete this.F[t],void 0!==this.O[t]&&delete this.O[t];for(const i in this.O)void 0!==this.O[i][t]&&delete this.O[i][t];i=!0}return i}StateOnEnterAdd(t,i){let s=!1;return void 0!==this.F[t]&&(this.F[t].OnEnter.includes(i)||(this.F[t].OnEnter.push(i),s=!0)),s}StateOnEnterDel(t,i){let s=!1;if(void 0!==this.F[t]){const e=this.F[t].OnEnter.indexOf(i);-1!==e&&(this.F[t].OnEnter.splice(e,1),s=!0)}return s}StateOnLeaveAdd(t,i){let s=!1;return void 0!==this.F[t]&&(this.F[t].OnLeave.includes(i)||(this.F[t].OnLeave.push(i),s=!0)),s}StateOnLeaveDel(t,i){let s=!1;if(void 0!==this.F[t]){const e=this.F[t].OnLeave.indexOf(i);-1!==e&&(this.F[t].OnLeave.splice(e,1),s=!0)}return s}TransitionAdd(t,i){let s=!1;return void 0!==this.F[t]&&void 0!==this.F[i]&&void 0===this.O[t][i]&&(this.O[t][i]={OnBefore:[],OnAfter:[]},s=!0),s}TransitionDel(t,i){let s=!1;return void 0!==this.F[t]&&void 0!==this.F[i]&&void 0!==this.O[t][i]&&(delete this.O[t][i],s=!0),s}TransitionOnBeforeAdd(t,i,s){let e=!1;return void 0!==this.F[t]&&void 0!==this.F[i]&&void 0!==this.O[t][i]&&(this.O[t][i].OnBefore.push(s),e=!0),e}TransitionOnBeforeDel(t,i,s){let e=!1;if(void 0!==this.F[t]&&void 0!==this.F[i]&&void 0!==this.O[t][i]){const h=this.O[t][i].OnBefore.indexOf(s);-1!==h&&(this.O[t][i].OnBefore.splice(h,1),e=!0)}return e}TransitionOnAfterAdd(t,i,s){let e=!1;return void 0!==this.F[t]&&void 0!==this.F[i]&&void 0!==this.O[t][i]&&(this.O[t][i].OnAfter.push(s),e=!0),e}TransitionOnAfterDel(t,i,s){let e=!1;if(void 0!==this.F[t]&&void 0!==this.F[i]&&void 0!==this.O[t][i]){const h=this.O[t][i].OnAfter.indexOf(s);-1!==h&&(this.O[t][i].OnAfter.splice(h,1),e=!0)}return e}StateGet(){return this._}async StateSet(t){let i=!1;if(!this.Z){if(this.Z=!0,void 0!==this._&&void 0!==this.F[t]&&void 0!==this.O[this._]&&void 0!==this.O[this._][t]){let s;i=!0,s=this.O[this._][t].OnBefore.length;for(let e=0;i&&e<s;e++)if("function"==typeof this.O[this._][t].OnBefore[e]){let s=null;s="AsyncFunction"===this.O[this._][t].OnBefore[e].constructor.name?await this.O[this._][t].OnBefore[e]():this.O[this._][t].OnBefore[e](),i=!1!==s}if(i){s=this.F[this._].OnLeave.length;for(let i=0;i<s;i++)"function"==typeof this.F[this._].OnLeave[i]&&("AsyncFunction"===this.F[this._].OnLeave[i].constructor.name?await this.F[this._].OnLeave[i](this._,t):this.F[this._].OnLeave[i](this._,t));let i=this._;this._=t,s=this.O[i][this._].OnAfter.length;for(let t=0;t<s;t++)"function"==typeof this.O[i][this._].OnAfter[t]&&("AsyncFunction"===this.O[i][this._].OnAfter[t].constructor.name?await this.O[i][this._].OnAfter[t]():this.O[i][this._].OnAfter[t]());s=this.F[this._].OnEnter.length;for(let t=0;t<s;t++)"function"==typeof this.F[this._].OnEnter[t]&&("AsyncFunction"===this.F[this._].OnEnter[t].constructor.name?await this.F[this._].OnEnter[t](this._,i):this.F[this._].OnEnter[t](this._,i))}}this.Z=!1}return i}CheckTransition(t){let i=!1;return this.Z||void 0!==this._&&void 0!==this.F[t]&&void 0!==this.O[this._]&&void 0!==this.O[this._][t]&&(i=!0),i}RouteSpecialAdd(t,i){let s=!1;switch(t){case 403:this.l=i,s=!0;break;case 404:this.v=i,s=!0;break;case 500:this.A=i,s=!0;break;default:throw new RangeError}return s}RouteAdd(i,s,e,h,n){let o=!1;if(void 0===this.F[i])throw new SyntaxError("Non-existent state");if(s.match(this.h))throw new SyntaxError("Duplicate path id");{let r=0;const a=s.split("/"),d=a.length;for(let t=0;t<d;t++)a[t].startsWith(":")||(r+=2**(d-t-1));let u=new RegExp("^"+s.replace(this.o,(function(t,i,s){let e="(?<"+i+">[";switch(s){case"09":e+="\\d";break;case"AZ":e+="a-zA-Z";break;default:e+="a-zA-Z\\d"}return e+="]+)",e})).replace(/\//g,"\\/")+"$");const c=s.replace(this.o,((t,i,s)=>`:${s??"AZ09"}`));this.u.find((i=>t.D(c,i.path)))||(this.u.push({path:c,validState:i,match:u,weight:r,routeFunction:e,available:h,routeFunction403:n}),this.u.sort(((t,i)=>t.weight>i.weight?-1:i.weight>t.weight?1:0)),o=!0)}return o}RouteDel(i){let s=!1;if(i.match(this.h))throw new SyntaxError("Duplicate path id");{const e=i.replace(this.o,((t,i,s)=>`:${s??"AZ09"}`)),h=this.u.findIndex((i=>t.D(e,i.path)));-1<h&&(this.u.splice(h,1),s=!0)}return s}Trigger(t){"#"+t!=window.location.hash&&(window.location.hash="#"+t)}async Route(t){let i;this.p=!0;let s="",e=null;for(const h of this.u)if(e=h.match.exec(t)){s=h.path;let n=!1;h.available&&"function"==typeof h.available&&(n="AsyncFunction"===h.available.constructor.name?await h.available(s,t,e.groups??{}):h.available(s,t,e.groups??{})),n&&(void 0===h.validState||this._===h.validState||this.CheckTransition(h.validState))?h.validState&&this._!==h.validState?(i=h.routeFunction,await this.StateSet(h.validState)||(i=this.A)):i=this.A:h.routeFunction403?i=h.routeFunction403:this.l&&(i=this.l);break}i||this.v&&(i=this.v),"function"!=typeof i&&this.A&&(i=this.A),i&&"function"==typeof i&&("AsyncFunction"===i.constructor.name?await i(s,t,e?.groups??{}):i(s,t,e?.groups??{})),this.S.length?await this.Route(this.S.shift()):this.p=!1}async CheckHash(){const t=window.location.hash.startsWith("#")?window.location.hash.substring(1):"";""!=t&&(this.p?this.S.push(t):await this.Route(t))}}export default t.i;